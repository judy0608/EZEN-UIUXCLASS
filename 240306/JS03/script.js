// iterable object 이터러블 객체
// iterable : 순차적인, 순서대로 무언가를 처리할 수 있는
// "순서"대로 어떠한 작업을 처리할 수 있는 객체
// "순서" = 인덱스 값처럼 순번 할당 값
// 이터러블 객체 = 문자열, 배열, Map, Set (in JS)

// 이터러블 객체가 아닌 요소들은 반복문을 사용할 수 있는 기회가 완전히 박탈된 것 일까?
// No! 태생이 이터러블 객체가 아니더라도 이 요소들을 이터러블 속성으로 변환시켜 반복문을 사용할 수 있도록 하기위한 목적.
// 그러므로 이터러블 객체의 어떤 속성이나 특징을 파악하고 그것을 적용시켜야한다.
// 이터러블 오브젝트의 특징
// 1) for...of 반복문 사용 가능
// 2) ...전개연산자 구문 사용 가능
// 3) 구조 분해 할당 가능.

// const hi = "hello";

// for (let ch of hi) {
//   console.log(ch);
// }

// const chArray = [...hi];

// console.log(chArray);

// const [ch1, ch2] = hi;
// console.log(ch1, ch2);

// 이터러블 하지 않은 객체 및 기타 요소들을 어떻게하면 이터러블 하게 만들수 있을까?
// 해결책을 찾기 위해서 이터러블 객체의 특징을 확인하기!

// 배열은 두가지 방법으로 생성.
const arr = [1, 2, 3, 4, 5];
console.log(arr);

const arr01 = new Array();

// 배열의 기원은 프로토타입 형식..!

// 배열이 이터러블한 객체가 되기 위해서 기원을 찾아보니..부모 요소에 클래스 생성자 함수에는 심볼이 존재하는데,
// "Symbol.iterator" 심볼 함수가 존재하기 때문에 배열은 이터러블한 객체가 될 수 있다.
// 이터러븛한 객체가 되기위해서는 해당 객체에 반드시 이터레이터 객체의 함수를 갖고있어야 한다.

// Symbol.iterable => next() (*핵심)

// 유사배열 => for /

// 이터러블 하지 않은 객체를 이터러블 한 객체로 변환시키기 위해서는 제너레이터 함수를 사용.
// 객체를 생성하는 것 자체 => 생성자 함수 혹은 class를 활용해서 프로토 타입 => 인스턴스화 하는 구조

const fnc = () => {
  console.log("1");
  console.log("2");
  console.log("3");
};

fnc();

// 순서에 따라 실행되어야 제너레이터 함수?
// 제너레이터 함수로 만들어주기 위해서는 반드시 function 뒤에 * 를 붙힌다

function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

let g1 = gen();

// g1 -> 제너레이터 객체 -> 이터러블한 객체가 됨.

const g2 = gen();

for (let i of g2) {
  console.log(i);
}
